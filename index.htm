<html>
  <head>
    <script src="https://unpkg.com/mithril/mithril.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/purecss@3.0.0/build/pure-min.css" integrity="sha384-X38yfunGUhNzHpBaEBsWLO+A0HDYOQi8ufWDkZ0k9e0eXz/tH3II7uKZ9msv++Ls" crossorigin="anonymous">
    <link href="https://cdn.jsdelivr.net/npm/keyrune@latest/css/keyrune.css" rel="stylesheet" type="text/css" />
    <link href=" https://cdn.jsdelivr.net/npm/@saeris/typeface-beleren-bold@1.0.1/index.min.css " rel="stylesheet">
    <title>MTGCollector</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="color-scheme" content="light dark">
    <style>
      :root {
        color-scheme: light dark;

        --col-text-main: #7f8c8d;
        --col-text-sub: #34495e;
        --col-text-href: #1f8dd6;
        --col-text-strong: black;
        --col-text-alt: white;

        --col-bg-main: white;
        --col-bg-alt: #d8f2ff;
        --col-bg-footer: #111;
      }

      @media (prefers-color-scheme: dark) {
        :root {
          --col-text-main: #c3c3c3;
          --col-text-sub: #eee;
          --col-text-href: #1f8dd6;
          --col-text-strong: white;
          --col-text-alt: black;

          --col-bg-main: #09111c;
          --col-bg-alt: #03334d;
          --col-bg-footer: #eee;
        }
      }

      body {
        line-height: 1.7em;
        font-size: 13px;
        color: var(--col-text-main);
        background: var(--col-bg-main);
      }

      h1, h2, h3, h4, h5, h6, label {
        color: var(--col-text-sub);
      }

      label {
        margin-right: 0.5em;
      }

      a {
        color: var(--col-text-href);
        text-decoration: none;
      }

      a[disabled] {
        color: var(--col-text-main);
      }

      fieldset {
        border: none;
      }

      header {
        background: linear-gradient(90deg, #00d2ff 0%, #3a47d5 100%);
        z-index: 1;
        width: 100%;
        height: 25%;
        top: 0;
        left: 0;
        position: fixed !important;
      }

      header h1 {
        font-size: 3em;
        font-weight: bold;
        color: white;
        padding: 1em 1.6em;
        font-weight: 100;
        border-radius: 5px;
        line-height: 1em;
        text-align: center;
        font-family: "Beleren Bold";
        text-shadow: 0px 0px 10px black;
      }

      main {
        position: absolute;
        top: 25%;
        width: 100%;
        min-height: 12%;
        z-index: 2;
        background: var(--col-bg-main);
      }

      footer {
        background: var(--col-bg-footer);
        color: var(--col-text-alt);
        position: fixed;
        bottom: 0;
        width: 100%;
        text-align: center;
      }

      #content {
        padding: 1em 1em 3em;
        max-width: 1280px;
        margin: 0 auto;
      }

      .control-group {
        display: inline-block;
        margin: 1em 3em 1em 0;
      }

      .sets {
        display: grid;
      }

      .sets .set {
        margin: 1em;
        display: flex;
        flex-direction: row;
        background-color: var(--col-bg-alt);
        padding: 1em;
        border-radius: 15px;
      }

      .sets .info {
        display: flex;
        flex-direction: column;
      }

      .sets .info ul {
        list-style-type: none;
        padding: 0;
        margin: 0;
      }

      .sets .info li {
        display: inline-block;
        margin-right: 2em;
      }

      .sets .ss {
        font-size: 350%;
        width: 68px;
        color: var(--col-text-href);
      }

      .sets a {
        font-size: 150%;
      }

      .cards {
        display: grid;
      }

      .cards .no-result {
        font-size: 120%;
        margin: 2em;
      }

      .cards .card {
        margin: 15px auto;
        display: flex;
        flex-direction: column;
        background-color: var(--col-bg-alt);
        border-radius: 15px;
      }

      .cards .card img {
        width: 250px;
        padding: 15px;
      }

      .cards .card .info {
        display: flex;
        flex-direction: column;
        padding: 0 15px 15px 15px;
        line-height: 1.3;
      }

      .cards .card .info .name {
        font-size: 110%;
      }

      .cards .card .strong {
        color: var(--col-text-strong);
      }

      .pagination {
        margin: 1em
      }

      .pagination a {
        margin-right: 0.6em;
        display: inline-block;
      }

      .stats {
        display: flex;
      }
      .stats ul {
        margin: 0 2em 0 0;
      }

      @media (min-width: 48em) {
        body {
          font-size: 16px;
        }
        header h1 {
          font-size: 5em;
        }
        .sets {
          grid-template-columns: auto auto;
        }
        .cards {
          grid-template-columns: auto auto;
        }
      }

      @media (min-width: 78em) {
        .sets {
          grid-template-columns: auto auto auto;
        }
        .cards {
          grid-template-columns: auto auto auto auto;
        }
      }
    </style>
    <script>
      var model = {
        set_data: [],
        user_data: [],
        stats: {
          total_worth: 0,
          card_sum: 0,
          unique_editions: 0,
          unique_cards: 0,
          mythics: 0,
          rares: 0,
          uncommons: 0,
          commons: 0
        },
        set_sort_order: "Ascending",
        set_sort_by: "Release",
        cards_sort_by: "Name",
        cards_sort_order: "Ascending",
        filter_rarity: "All",
        items_per_page: 25
      }

      var setOrig = m.route.set;
      m.route.set = function(path, data, options) {
        setOrig(path, data, options);
        window.scrollTo(0,0);
      }

      var linkOrig = m.route.link;
      m.route.link = function(vnode) {
        linkOrig(vnode);
        window.scrollTo(0,0);
      }

      var indexpage = {
        view: function(vnode) {
          return [
            m("h1", "Upload Manabox .csv"),
            m("input", {type: "file", id: "csv", name: "csv", accept: ".csv", onchange: function() {
              for (const file of event.target.files) {
                const reader = new FileReader();
                reader.onload = function(e) {
                  localStorage.setItem("user_data", reader.result);
                  reloadData();
                  m.redraw();
                };
                reader.readAsText(file);
              }
            }}),
            m("div", {style: {display: model.user_data.length > 0 ? "" : "none"}}, [
              m("h1", "Stats"),
              m("div", {class: "stats"}, [
                m("ul", [
                  m("li", model.stats.card_sum + " cards loaded"),
                  m("li", model.stats.unique_cards + " unique cards"),
                  m("li", model.stats.unique_editions + " unique editions"),
                  m("li", "$" + model.stats.total_worth + " total worth"),
                ]),
                m("ul", [
                  m("li", model.stats.mythics + " mythics"),
                  m("li", model.stats.rares + " rares"),
                  m("li", model.stats.uncommons + " uncommons"),
                  m("li", model.stats.commons + " commons")
                ])
              ]),
              m("h1", "Search"),
              m("input", {type: "text", onkeyup: function(e) { if(e.code == "Enter") m.route.set("/search/:term/page/1", {term: this.value}) }}),
              m("h1", [
                m(m.route.Link, {href: "/all/page/1"}, "Browse All Cards")
              ]),
              m("h1", "Browse Sets"),
              m("fieldset", [
                m("div", {class: "control-group"}, [
                  m("label", {for: "sort-by"}, "Sort By: "),
                  m("select", {id: "sort-by", onchange: function(e) {
                    model.set_sort_by = e.target.value;
                  }}, [
                    m("option", {selected: model.set_sort_by == "Release"}, "Release"),
                    m("option", {selected: model.set_sort_by == "Name"}, "Name")
                  ])
                ]),
                m("div", {class: "control-group"}, [
                  m("label", {for: "sort-order"}, "Sort Order: "),
                  m("select", {id: "sort-order", onchange: function(e) {
                    model.set_sort_order = e.target.value;
                  }}, [
                    m("option", {selected: model.set_sort_order == "Ascending"}, "Ascending"),
                    m("option", {selected: model.set_sort_order == "Descending"}, "Descending")
                  ])
                ])
              ]),
              m("div", {class : "sets"}, [
                model.set_data
                  // filter out first item which is csv column names
                  .filter((item, index, arr) => arr.indexOf(item) != 0)
                  // filter out editions that we don't have
                  .filter(item => model.user_data.map(x => x[1]).indexOf(item[3]) != -1)
                  // sort data
                  .sort(function(a, b) {
                    if (model.set_sort_by == "Release" && model.set_sort_order == "Ascending")
                      return new Date(a[17]).getTime() - new Date(b[17]).getTime();
                    if (model.set_sort_by == "Release" && model.set_sort_order == "Descending")
                      return new Date(b[17]).getTime() - new Date(a[17]).getTime();
                    if (model.set_sort_by == "Name" && model.set_sort_order == "Ascending")
                      return ('' + a[15]).localeCompare(b[15]);
                    if (model.set_sort_by == "Name" && model.set_sort_order == "Descending")
                      return ('' + b[15]).localeCompare(a[15]);
                  })
                  .map(function(item) {
                    return m("div", {class: "set"}, [
                      m("i", {class: "ss ss-" + item[3]}),
                      m("div", {class: "info"}, [
                        m(m.route.Link, {href: "/set/" + item[3] + "/page/1"}, [
                          m("span", item[15])
                        ]),
                        m("span", item[17]),
                        m("ul", [
                          m("li", model.user_data
                            .filter(x => x[1] == item[3])
                            .map(x => parseInt(x[6]))
                            .reduce((x, y) => x + y) + " card(s)"
                          ),
                          m("li", "$" + model.user_data
                            .filter(x => x[1] == item[3])
                            .filter(x => x[9] != '')
                            .map(x => parseFloat(x[9]) * parseInt(x[6]))
                            .reduce((x, y) => x + y, 0)
                            .toFixed(2)
                          )
                        ])
                      ])
                    ])
                  })
                ]),
            ])
          ]}
      }

      var cardpage = {
        pagination: function(vnode, prefix, pages_len) {
          let pages = [];
          let min_page = Math.max(parseInt(vnode.attrs.page) - 10, 1);
          let max_page = Math.min(min_page + 20, pages_len);
          for(let i=min_page; i<= max_page; i++) {
            pages.push(m(m.route.Link, {href: prefix + "/page/" + i, disabled: vnode.attrs.page == i}, i));
          }

          return m("div", {class: "pagination"}, [
            m("label", "Page: "),
            m(m.route.Link, {href: "/"}, "Home"),
            min_page == 1 ? '' : m(m.route.Link, {href: prefix + "/page/1"}, "First"),
            pages_len == 0 ? '' : m(m.route.Link, {href: prefix + "/page/" + (parseInt(vnode.attrs.page)-1), disabled: vnode.attrs.page == 1}, "Previous"),
            pages,
            pages_len == 0 ? '' : m(m.route.Link, {href: prefix + "/page/" + (parseInt(vnode.attrs.page)+1), disabled: vnode.attrs.page == pages_len}, "Next"),
            max_page != pages_len ? m(m.route.Link, {href: prefix + "/page/" + pages_len}, "Last") : ''
          ]);
        },
        view: function(vnode) {
          let title = "Browsing all cards";
          let page = "/all"
          if(vnode.attrs.set) {
            title = "Browsing set: " + model.set_data.filter(x => x[3] == vnode.attrs.set)[0][15];
            page = "/set/" + vnode.attrs.set;
          }
          else if(vnode.attrs.term) {
            title = "Search Result for '" + vnode.attrs.term + "'"
            page = "/search/" + vnode.attrs.term;
          }

          let cards = model.user_data
            // filter out first item which is csv column names
            .filter((item, index, arr) => arr.indexOf(item) != 0)
            // rarity filter
            .filter(function(item) {
              if(model.filter_rarity == "All")
                return true;
              return item[5] == model.filter_rarity.toLowerCase();
            })
            .sort(function(a, b) {
              if (model.cards_sort_by == "Name" && model.cards_sort_order == "Ascending")
                return ('' + a[0]).localeCompare(b[0]);
              if (model.cards_sort_by == "Name" && model.cards_sort_order == "Descending")
                return ('' + b[0]).localeCompare(a[0]);
              if (model.cards_sort_by == "Quantity" && model.cards_sort_order == "Ascending")
                return a[6] - b[6];
              if (model.cards_sort_by == "Quantity" && model.cards_sort_order == "Descending")
                return b[6] - a[6];
              if (model.cards_sort_by == "Unit Price" && model.cards_sort_order == "Ascending")
                return a[9] - b[9];
              if (model.cards_sort_by == "Unit Price" && model.cards_sort_order == "Descending")
                return b[9] - a[9];
            })
            // filter based on which page we're on
            .filter(function(item) {
              if(vnode.attrs.set)
                return item[1] == vnode.attrs.set
              else if(vnode.attrs.term)
                return item[0].toLowerCase().indexOf(vnode.attrs.term.toLowerCase()) > -1
              return true;
            });

          let pages_len = Math.ceil(cards.length / model.items_per_page);

          return [
            m("h1", title),
            m("fieldset", [
              m("div", {class: "control-group"}, [
                m("label", {for: "sort-by"}, "Sort By: "),
                m("select", {id: "sort-by", onchange: function(e) {
                  model.cards_sort_by = e.target.value;
                }}, [
                  m("option", {selected: model.cards_sort_by == "Name"}, "Name"),
                  m("option", {selected: model.cards_sort_by == "Quantity"}, "Quantity"),
                  m("option", {selected: model.cards_sort_by == "Unit Price"}, "Unit Price"),
                ])
              ]),
              m("div", {class: "control-group"}, [
                m("label", {for: "sort-order"}, "Sort Order: "),
                m("select", {id: "sort-order", onchange: function(e) {
                  model.cards_sort_order = e.target.value;
                }}, [
                  m("option", {selected: model.cards_sort_order == "Ascending"}, "Ascending"),
                  m("option", {selected: model.cards_sort_order == "Descending"}, "Descending")
                ])
              ]),
              m("div", {class: "control-group"}, [
                m("label", {for: "items-per-page"}, "Rarity: "),
                m("select", {id: "items-per-page", onchange: function(e) {
                  model.filter_rarity = e.target.value;
                }}, [
                  m("option", {selected: model.filter_rarity == "All"}, "All"),
                  m("option", {selected: model.filter_rarity == "Mythic"}, "Mythic"),
                  m("option", {selected: model.filter_rarity == "Rare"}, "Rare"),
                  m("option", {selected: model.filter_rarity == "Uncommon"}, "Uncommon"),
                  m("option", {selected: model.filter_rarity == "Common"}, "Common")
                ])
              ]),
              m("div", {class: "control-group"}, [
                m("label", {for: "items-per-page"}, "Items per page: "),
                m("select", {id: "items-per-page", onchange: function(e) {
                  model.items_per_page = parseInt(e.target.value);
                }}, [
                  m("option", {selected: model.items_per_page == 10}, "10"),
                  m("option", {selected: model.items_per_page == 25}, "25"),
                  m("option", {selected: model.items_per_page == 100}, "100")
                ])
              ])
            ]),
            this.pagination(vnode, page, pages_len),
            m("div", {class: "cards"}, [
              cards
                // pagination
                .filter(function(item, index, arr) {
                  return arr.indexOf(item) < vnode.attrs.page * model.items_per_page &&
                         arr.indexOf(item) >= (vnode.attrs.page-1) * model.items_per_page;
                })
                .map(function(item) {
                  let img = "https://cards.scryfall.io/normal/front/" + item[8][0] + "/" + item[8][1] + "/" + item[8] + ".jpg";

                  return m("div", {class: "card"}, [
                    m("img", {src: img}),
                    m("div", {class: "info"}, [
                      m("span", {class: "name strong"}, item[0]),
                      m("span", "Unit Price: ", [
                        m("span", {class: "strong"}, item[9] == '' ? '' : '$' + parseFloat(item[9]).toFixed(2))
                      ]),
                      m("span", "Quantity: ", [
                        m("span", {class: "strong"}, item[6])
                      ])
                    ])
                  ]);
                }),
              cards.length > 0 ? '' : m("span", {class: "no-result"}, "No results found!")
            ]),
            this.pagination(vnode, page, pages_len),
          ]
        }
      }

      function reloadData() {
        Papa.parse("https://mtgjson.com/api/v5/csv/sets.csv", {
          download: true,
          complete: function(results) {
            model.set_data = results.data;
            let ud = localStorage.getItem("user_data");
            if (ud == null)
              ud = "";
            Papa.parse(ud, {
              complete: function(results) {
                model.user_data = results.data;

                model.stats.card_sum = model.user_data
                  // filter out first item which is csv column names
                  .filter((item, index, arr) => arr.indexOf(item) != 0)
                  // sum all quanitity column values
                  .map(x => parseInt(x[6]))
                  .reduce((x, y) => x + y, 0)

                model.stats.total_worth = model.user_data
                  // filter out first item which is csv column names
                  .filter((item, index, arr) => arr.indexOf(item) != 0)
                  // filter out empty prices
                  .filter(item => item[9] != '')
                  // sum all price column values
                  .map(x => parseFloat(x[9]) * parseInt(x[6]))
                  .reduce((x, y) => x + y, 0)
                  .toFixed(0)

                model.stats.mythics = model.user_data
                  // filter for rarity
                  .filter(item => item[5] == "mythic")
                  // sum all quanitity column values
                  .map(x => parseInt(x[6]))
                  .reduce((x, y) => x + y, 0)

                model.stats.rares = model.user_data
                  // filter for rarity
                  .filter(item => item[5] == "rare")
                  // sum all quanitity column values
                  .map(x => parseInt(x[6]))
                  .reduce((x, y) => x + y, 0)

                model.stats.uncommons = model.user_data
                  // filter for rarity
                  .filter(item => item[5] == "uncommon")
                  // sum all quanitity column values
                  .map(x => parseInt(x[6]))
                  .reduce((x, y) => x + y, 0)

                model.stats.commons = model.user_data
                  // filter for rarity
                  .filter(item => item[5] == "common")
                  // sum all quanitity column values
                  .map(x => parseInt(x[6]))
                  .reduce((x, y) => x + y, 0)

                model.stats.unique_editions = model.set_data
                  // filter out first item which is csv column names
                  .filter((item, index, arr) => arr.indexOf(item) != 0)
                  // filter out editions that we don't have
                  .filter(item => model.user_data.map(x => x[1]).indexOf(item[3]) != -1)
                  .length;

                model.stats.unique_cards = [...new Set(model.user_data.map(x => x[0]))].length;

                m.route(document.getElementById("content"), "/", {
                  "/": indexpage,
                  "/all/page/:page": cardpage,
                  "/set/:set/page/:page": cardpage,
                  "/search/:term/page/:page": cardpage
                });
              }
            });
          }
        });
      }

      document.addEventListener("DOMContentLoaded", reloadData);
    </script>
  </head>
  <body>
    <header>
      <h1>MTGCollector</h1>
    </header>
    <main>
        <div id="content">
        </div>
        <footer> (C) 2025 8bitmcu</footer>
    </main>
  </body>
</html>
